{% extends "navbar.html" %}
{% block title %}Hyperion Dashboard{% endblock %} 
{%block content %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script id="cpu-data" type="application/json">
  [{ "recorded_at": "2023-10-01T00:00:00Z", "usage": 20 }]
</script>
<script id="memory-data" type="application/json">
  [{ "recorded_at": "2023-10-01T00:00:00Z", "usage": 50 }]
</script>
<script id="network-data" type="application/json">
  [{ "recorded_at": "2023-10-01T00:00:00Z", "usage": 10 }]
</script>
<div class="main-content" role="main" aria-label="Contenu principal du tableau de bord" id="main-content">
  <header>
    <h1>Hyperion Dashboard</h1>
    <button class="theme-toggle accessible-button" onclick="toggleTheme()" aria-label="Basculer le thème clair/sombre" tabindex="0">
      <i class="fas fa-adjust" aria-hidden="true"></i>
      <span>Toggle Theme</span>
    </button>
  </header>
  <main>
    <!-- Section des processus -->
    <section class="container" id="monitoring" aria-labelledby="processes-title">
      <div class="widget" id="processes">
        <h2 id="processes-title">Processus système</h2>
        <p class="widget-description">
          Surveillance et gestion des processus en cours d'exécution sur le système.
        </p>
        
        <h3>Fonctionnalités :</h3>
        <ul>
          <li>Filtrage des processus par nom</li>
          <li>Tri par CPU, Mémoire, Nom</li>
          <li>Affichage des détails (Nom, PID, Statut, CPU%, Mémoire%)</li>
          <li>Actions de gestion (arrêt, redémarrage, modification de priorité)</li>
          <li>Mises à jour en temps réel via WebSocket</li>
        </ul>

        <div class="controls" role="group" aria-labelledby="process-controls-label">
          <h4 id="process-controls-label" class="sr-only">Contrôles des processus</h4>
          
          <div class="form-group">
            <label for="processFilter" class="form-label">Filtrer les processus</label>
            <input
              type="text"
              id="processFilter"
              name="process_filter"
              class="form-input"
              placeholder="Nom du processus..."
              onkeyup="filterProcesses()"
              aria-describedby="processFilter-help"
            />
            <div id="processFilter-help" class="form-help">
              Tapez le nom d'un processus pour le filtrer dans la liste
            </div>
          </div>

          <div class="form-group">
            <label for="processSorting" class="form-label">Trier par</label>
            <select 
              id="processSorting" 
              name="process_sorting" 
              class="form-input"
              onchange="sortProcesses()"
              aria-describedby="processSorting-help"
            >
              <option value="cpu">Utilisation CPU</option>
              <option value="memory">Utilisation mémoire</option>
              <option value="name">Nom du processus</option>
            </select>
            <div id="processSorting-help" class="form-help">
              Sélectionnez le critère de tri pour organiser la liste
            </div>
          </div>
        </div>

        <div class="scrollable-list" role="region" aria-labelledby="processes-table-caption">
          <table class="process-table accessible-table" style="width: 100%; table-layout: fixed">
            <caption id="processes-table-caption">
              Liste des processus système avec leurs statistiques d'utilisation
            </caption>
            <thead>
              <tr>
                <th scope="col" id="process-name">
                  <button class="table-sort-button" onclick="sortProcesses('name')" 
                          aria-label="Trier par nom de processus">
                    Nom <i class="fas fa-sort" aria-hidden="true"></i>
                  </button>
                </th>
                <th scope="col" id="process-pid">PID</th>
                <th scope="col" id="process-status">Statut</th>
                <th scope="col" id="process-cpu">
                  <button class="table-sort-button" onclick="sortProcesses('cpu')" 
                          aria-label="Trier par utilisation CPU">
                    CPU % <i class="fas fa-sort" aria-hidden="true"></i>
                  </button>
                </th>
                <th scope="col" id="process-memory">
                  <button class="table-sort-button" onclick="sortProcesses('memory')" 
                          aria-label="Trier par utilisation mémoire">
                    Mémoire % <i class="fas fa-sort" aria-hidden="true"></i>
                  </button>
                </th>
                <th scope="col" id="process-actions">Actions</th>
              </tr>
            </thead>
            <tbody id="processesTableBody" aria-live="polite" aria-atomic="false">
              <!-- Les processus seront injectés ici via JavaScript -->
              <tr class="loading-row">
                <td colspan="6" role="status" aria-label="Chargement des processus en cours">
                  <i class="fas fa-spinner fa-spin" aria-hidden="true"></i>
                  Chargement des processus...
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <!-- Section des services -->
      <section class="widget" id="services" aria-labelledby="services-title">
        <h2 id="services-title">Services système</h2>
        <p class="widget-description">
          Gestion et surveillance des services système actifs.
        </p>
        
        <h3>Fonctionnalités :</h3>
        <ul>
          <li>Affichage des détails des services (Nom, Statut)</li>
          <li>Actions de gestion (démarrer, arrêter, redémarrer)</li>
          <li>Mises à jour en temps réel via WebSocket</li>
          <li>Indicateurs de statut visuels</li>
          <li>Liste complète des services</li>
        </ul>

        <div class="scrollable-list" role="region" aria-labelledby="services-table-caption">
          <table class="service-table accessible-table" style="width: 100%; table-layout: fixed">
            <caption id="services-table-caption">
              Liste des services système et de leur statut
            </caption>
            <thead>
              <tr>
                <th scope="col" id="service-name">Nom du service</th>
                <th scope="col" id="service-status">Statut</th>
                <th scope="col" id="service-actions">Actions disponibles</th>
              </tr>
            </thead>
            <tbody id="servicesTableBody" aria-live="polite" aria-atomic="false">
              <!-- Les services seront injectés ici via JavaScript -->
              <tr class="loading-row">
                <td colspan="3" role="status" aria-label="Chargement des services en cours">
                  <i class="fas fa-spinner fa-spin" aria-hidden="true"></i>
                  Chargement des services...
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- Section des graphiques -->
      <section class="charts-container" aria-labelledby="metrics-title">
        <div class="widget">
          <h2 id="metrics-title">Métriques système</h2>
          <p class="widget-description">
            Graphiques en temps réel de l'utilisation des ressources système.
          </p>
          
          <h3>Fonctionnalités :</h3>
          <ul>
            <li>Graphiques temps réel CPU, Mémoire, Réseau</li>
            <li>Basculement entre les différents graphiques</li>
            <li>Design adaptatif</li>
            <li>Mises à jour en temps réel via WebSocket</li>
          </ul>

          <div class="chart-controls" role="group" aria-labelledby="chart-controls-label">
            <h4 id="chart-controls-label">Sélection du graphique</h4>
            
            <div class="form-group">
              <label for="chartSelector" class="form-label">Type de métrique</label>
              <select 
                id="chartSelector" 
                name="chart_selector" 
                class="form-input"
                onchange="switchChart()"
                aria-describedby="chartSelector-help"
              >
                <option value="cpu">Utilisation CPU</option>
                <option value="memory">Utilisation mémoire</option>
                <option value="network">Utilisation réseau</option>
              </select>
              <div id="chartSelector-help" class="form-help">
                Sélectionnez la métrique à afficher dans le graphique
              </div>
            </div>
          </div>

          <div role="region" aria-labelledby="current-chart-title">
            <h3 id="current-chart-title">Graphique d'utilisation CPU</h3>
            
            <!-- Conteneurs de graphiques accessibles -->
            <div
              id="cpuChartContainer"
              class="chart-container"
              style="height: 300px"
              role="img"
              aria-labelledby="cpu-chart-title"
              aria-describedby="cpu-chart-description"
            >
              <h4 id="cpu-chart-title" class="sr-only">Graphique d'utilisation CPU</h4>
              <canvas 
                id="cpuChart"
                role="img"
                aria-label="Graphique en temps réel de l'utilisation CPU"
                tabindex="0"
              ></canvas>
              <div id="cpu-chart-description" class="chart-description sr-only">
                Évolution de l'utilisation du processeur au cours du temps, 
                exprimée en pourcentage de 0 à 100%.
              </div>
            </div>

            <div
              id="memoryChartContainer"
              class="chart-container"
              style="display: none; height: 300px"
              role="img"
              aria-labelledby="memory-chart-title"
              aria-describedby="memory-chart-description"
            >
              <h4 id="memory-chart-title" class="sr-only">Graphique d'utilisation mémoire</h4>
              <canvas 
                id="memoryChart"
                role="img"
                aria-label="Graphique en temps réel de l'utilisation mémoire"
                tabindex="0"
              ></canvas>
              <div id="memory-chart-description" class="chart-description sr-only">
                Évolution de l'utilisation de la mémoire vive au cours du temps, 
                exprimée en pourcentage de 0 à 100%.
              </div>
            </div>

            <div
              id="networkChartContainer"
              class="chart-container"
              style="display: none"
              role="img"
              aria-labelledby="network-chart-title"
              aria-describedby="network-chart-description"
            >
              <h4 id="network-chart-title" class="sr-only">Graphique d'utilisation réseau</h4>
              <canvas 
                id="networkChart"
                role="img"
                aria-label="Graphique en temps réel de l'utilisation réseau"
                tabindex="0"
              ></canvas>
              <div id="network-chart-description" class="chart-description sr-only">
                Évolution du trafic réseau au cours du temps, 
                exprimé en pourcentage de bande passante utilisée.
              </div>
            </div>

            <!-- Contrôles d'accessibilité pour les graphiques -->
            <div class="chart-accessibility-controls">
              <button 
                type="button" 
                class="accessible-button" 
                onclick="toggleChartData()"
                aria-expanded="false"
                aria-controls="chart-data-table"
                aria-label="Afficher les données du graphique sous forme de tableau"
              >
                <i class="fas fa-table" aria-hidden="true"></i>
                <span>Voir les données</span>
              </button>
              
              <div id="chart-data-table" class="chart-data-table" style="display: none;">
                <table class="accessible-table">
                  <caption>Données numériques du graphique actuel</caption>
                  <thead>
                    <tr>
                      <th scope="col">Temps</th>
                      <th scope="col">Valeur (%)</th>
                    </tr>
                  </thead>
                  <tbody id="chartDataTableBody" aria-live="polite">
                    <!-- Données injectées par JavaScript -->
                    <tr>
                      <td colspan="2">Aucune donnée disponible</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- Storage Widget -->
      <div class="widget" id="storage">
        <h3>Storage Analysis</h3>
        <h4>Features:</h4>
        <ul>
          <li>Display storage details (Mount Point, Device, Filesystem, Usage)</li>
          <li>Storage usage progress bar</li>
          <li>Real-time updates via StorageConsumer WebSocket</li>
          <li>Storage size and usage information</li>
        </ul>
        <div class="storage-container scrollable-list">
          <div id="storageList"></div>
        </div>
      </div>
      <!-- Temperature Widget -->
      <div class="widget" id="temperature">
        <h3>System Temperatures</h3>
        <h4>Features:</h4>
        <ul>
          <li>Display temperature details (Device, Sensor, Current, Max, Critical)</li>
          <li>Temperature progress bar with warning and critical levels</li>
          <li>Real-time updates via TemperatureConsumer WebSocket</li>
          <li>Temperature unit and sensor information</li>
          <li>WARNING : Some features depends on the os and the hardware</li>
        </ul>
        <div class="temperature-container scrollable-list">
          <div id="temperatureList"></div>
        </div>
      </div>
      <div class="widget" id="network">
        <h3>Network Security</h3>
        <h4>Features:</h4>
        <ul>
          <li>Block IP addresses</li>
          <li>Block ports (TCP, UDP)</li>
          <li>Configure network interfaces</li>
          <li>Real-time updates via NetworkConsumer WebSocket</li>
          <li>Interface IP configuration</li>
        </ul>
        <div class="network-controls">
          <!-- IP Blocking -->
          <div class="control-group ip-blocking">
            <input
              type="text"
              id="ipAddress"
              placeholder="IP Address (ex: 192.168.1.1)"
            />
            <button
              onclick="blockIP(document.getElementById('ipAddress').value)"
            >
              Block IP
            </button>
          </div>

          <!-- Port Management -->
          <div class="control-group port-blocking">
            <input type="number" id="portNumber" placeholder="Port (1-65535)" />
            <select id="protocol" name="protocol">
              <option value="tcp">TCP</option>
              <option value="udp">UDP</option>
            </select>
            <button
              onclick="blockPort(
                    document.getElementById('portNumber').value,
                    document.getElementById('protocol').value
                )"
            >
              Block Port
            </button>
          </div>

          <!-- Interface Configuration -->
          <div class="control-group interface-config">
            <select id="networkInterface" name="network_interface">
              <option value="">Select Interface</option>
            </select>
            <input type="text" id="ipConfig" placeholder="IP Configuration" />
            <input type="number" id="mtu" placeholder="MTU" />
            <button
              onclick="configureInterface(
                    document.getElementById('networkInterface').value,
                    {
                        ip_address: document.getElementById('ipConfig').value,
                        mtu: document.getElementById('mtu').value
                    }
                )"
            >
              Configure Interface
            </button>
          </div>
        </div>
      </div>
      <!-- File Management -->
      <div class="widget" id="files">
        <h3>File Management</h3>
        <h4>Features:</h4>
        <ul>
          <li>File and directory listing</li>
          <li>File size, type, modified date, permissions</li>
          <li>File management actions (open directory, delete file)</li>
          <li>Real-time updates via FileConsumer WebSocket</li>
        </ul>
        <div class="file-controls">
          <input type="text" id="currentPath" value="/" readonly />
          <button onclick="navigateUp()">Up</button>
          <button onclick="refreshFiles()">Refresh</button>
        </div>
        <div
          class="scrollable-list"
          id="fileList"
          ondrop="handleDrop(event)"
          ondragover="handleDragOver(event)"
        >
          <table class="file-table">
            <thead>
              <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Size</th>
                <th>Modified</th>
                <th>Permissions</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="fileTableBody"></tbody>
          </table>
        </div>
      </div>
      <!-- Shell -->
      <div class="widget" id="shell">
        <h3>Shell</h3>
        <h4>Features:</h4>
        <ul>
          <li>Real-time shell output</li>
        </ul>
        <div class="shell-container">
          <div id="shellOutput" class="shell-output"></div>
          <div class="shell-input">
            <input
              type="text"
              id="shellCommand"
              placeholder="Enter command..."
            />
            <button onclick="sendCommand()">Send</button>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

<!-- Add mobile menu toggle button -->
<button class="mobile-menu-toggle show-on-mobile" onclick="toggleMobileMenu()">
  <i class="fas fa-bars"></i>
</button>

<script>
    let cpuChart, memoryChart, networkChart, fileSocket;

      document.addEventListener('DOMContentLoaded', function () {
          const navLinks = document.querySelectorAll('.nav-menu a');

          navLinks.forEach(link => {
              link.addEventListener('click', function (e) {
                  // Enlever la classe active de tous les liens
                  navLinks.forEach(l => l.classList.remove('active'));
                  // Ajouter la classe active au lien cliqué
                  this.classList.add('active');
              });
          });

          fileSocket = new WebSocket(
              "ws://" + window.location.host + "/ws/files/"
          );

          fileSocket.onmessage = function(e) {
              const data = JSON.parse(e.data);
              if (data.type === 'file_list') {
                  updateFileTable(data.data);
              }
          };
      });

      const cpuData = JSON.parse(
          document.getElementById("cpu-data").textContent
      );
      const memoryData = JSON.parse(
          document.getElementById("memory-data").textContent
      );
      const networkData = JSON.parse(
          document.getElementById("network-data").textContent
      );

      const networkChartCtx = document
          .getElementById("networkChart")
          .getContext("2d");

          networkChart = new Chart(networkChartCtx, {
            type: "line",
            data: {
                labels: [],
                datasets: [
                    {
                        label: "Received",
                        data: [],
                        borderColor: "rgba(255, 99, 132, 1)",
                        backgroundColor: "rgba(255, 99, 132, 0.2)",
                        fill: false,
                    },
                    {
                        label: "Sent",
                        data: [],
                        borderColor: "rgba(54, 162, 235, 1)",
                        backgroundColor: "rgba(54, 162, 235, 0.2)",
                        fill: false,
                    },
                ],
            },
            options: {
                responsive: true,
                maintainAspectRatio: false
            }
        });

      function switchChart() {
          const selectedChart = document.getElementById('chartSelector').value;

          // Hide all charts
          document.getElementById('cpuChartContainer').style.display = 'none';
          document.getElementById('memoryChartContainer').style.display = 'none';
          document.getElementById('networkChartContainer').style.display = 'none';

          // Show selected chart
          document.getElementById(`${selectedChart}ChartContainer`).style.display = 'block';

          // Trigger resize to fix chart rendering
          window.dispatchEvent(new Event('resize'));
      }

      // Initial load
      document.addEventListener('DOMContentLoaded', function () {
          switchChart();
      });

      function toggleTheme() {
          document.body.classList.toggle("dark-mode");
      }

      {% comment %}  WebSockets code for updating processes {% endcomment %}
      const processesSocket = new WebSocket(
          "ws://" + window.location.host + "/ws/processes/"
      );

      processesSocket.onmessage = function (e) {
          const processes = JSON.parse(e.data);
          if (Array.isArray(processes)) {
              updateProcessTable(processes);
          }
      };

      function updateProcessTable(processes) {
          const tbody = document.getElementById("processesTableBody");
          const currentFilter = document.getElementById("processFilter").value.toLowerCase();
          const currentSort = document.getElementById("processSorting").value;

          // Preserve current scroll position
          const scrollPosition = tbody.parentElement.scrollTop;

          tbody.innerHTML = "";
          processes
              .filter(process => process.name.toLowerCase().includes(currentFilter))
              .sort((a, b) => {
                  if (currentSort === "cpu") {
                      return b.cpu_percent - a.cpu_percent;
                  } else if (currentSort === "memory") {
                      return b.memory_percent - a.memory_percent;
                  } else {
                      return a.name.localeCompare(b.name);
                  }
              })
              .forEach((process) => {
                  const row = document.createElement("tr");
                  row.innerHTML = `
                                  <td>${process.name}</td>
                                  <td>${process.pid}</td>
                                  <td>${process.status}</td>
                                  <td>${process.cpu_percent?.toFixed(1) || 0}%</td>
                                  <td>${process.memory_percent?.toFixed(1) || 0}%</td>
                                  <td>
                                      <button class="process-action stop-btn" onclick="stopProcess(${process.pid})">Stop</button>
                                      <select class="process-action priority-select" onchange="changePriority(${process.pid}, this.value)" id="priority-${process.pid}" name="priority">
                                          <option value="-20">Highest</option>
                                          <option value="0">Normal</option>
                                          <option value="19">Lowest</option>
                                      </select>
                                  </td>
                              `;
                  tbody.appendChild(row);
              });

          // Restore scroll position
          tbody.parentElement.scrollTop = scrollPosition;
      }

      function stopProcess(pid) {
          processesSocket.send(
              JSON.stringify({
                  action: "stop",
                  pid: pid,
              })
          );
      }

      function changePriority(pid, priority) {
          processesSocket.send(
              JSON.stringify({
                  action: "priority",
                  pid: pid,
                  priority: parseInt(priority),
              })
          );
      }

      function filterProcesses() {
          const filter = document
              .getElementById("processFilter")
              .value.toLowerCase();
          const rows = document
              .getElementById("processesTableBody")
              .getElementsByTagName("tr");

          for (let row of rows) {
              const name = row.cells[0].textContent.toLowerCase();
              row.style.display = name.includes(filter) ? "" : "none";
          }
      }

      function sortProcesses() {
          const sortBy = document.getElementById("processSorting").value;
          const tbody = document.getElementById("processesTableBody");
          const rows = Array.from(tbody.getElementsByTagName("tr"));

          rows.sort((a, b) => {
              const aVal =
                  a.cells[sortBy === "cpu" ? 3 : sortBy === "memory" ? 4 : 0]
                      .textContent;
              const bVal =
                  b.cells[sortBy === "cpu" ? 3 : sortBy === "memory" ? 4 : 0]
                      .textContent;
              return sortBy === "name"
                  ? aVal.localeCompare(bVal)
                  : parseFloat(bVal) - parseFloat(aVal);
          });

          rows.forEach((row) => tbody.appendChild(row));
      }

      {% comment %}  WebSockets code for updating services {% endcomment %}
      const servicesSocket = new WebSocket(
          "ws://" + window.location.host + "/ws/services/"
      );

      servicesSocket.onmessage = function (e) {
          const services = JSON.parse(e.data);
          if (Array.isArray(services)) {
              updateServiceTable(services);
          }
      };

      function updateServiceTable(services) {
          const tbody = document.getElementById("servicesTableBody");
          // Preserve scroll position
          const scrollPosition = tbody.parentElement.scrollTop;

          tbody.innerHTML = "";
          services.forEach((service) => {
              const row = document.createElement("tr");
              row.innerHTML = `
                      <td>${service.name}</td>
                      <td><span class="status-badge ${service.status.toLowerCase()}">${service.status}</span></td>
                      <td>
                          <button class="service-action start-btn" onclick="controlService('${service.name}', 'start')">Start</button>
                          <button class="service-action stop-btn" onclick="controlService('${service.name}', 'stop')">Stop</button>
                          <button class="service-action restart-btn" onclick="controlService('${service.name}', 'restart')">Restart</button>
                      </td>
                  `;
              tbody.appendChild(row);
          });

          // Restore scroll position
          tbody.parentElement.scrollTop = scrollPosition;
      }

      function controlService(serviceName, action) {
          servicesSocket.send(JSON.stringify({
              action: action,
              service: serviceName
          }));
      }

      const networkSocket = new WebSocket(
          "ws://" + window.location.host + "/ws/networks/"
      );

      networkSocket.onmessage = function (e) {
          const data = JSON.parse(e.data);
          if (data.usage && Array.isArray(data.usage)) {
              const networkChart = Chart.getChart("networkChart");
              networkChart.data.labels = data.usage.map(d => d.recorded_at);
              networkChart.data.datasets[0].data = data.usage.map(d => d.received);
              networkChart.data.datasets[1].data = data.usage.map(d => d.sent);
              networkChart.update();
          }
      };

      function blockIP(ip) {
          networkSocket.send(JSON.stringify({
              action: 'block_ip',
              ip_address: ip
          }));
      }

      function configureInterface(interface, config) {
          networkSocket.send(JSON.stringify({
              action: 'configure_interface',
              interface: interface,
              config: config
          }));
      }

      // CPU WebSocket connection and chart
      const cpuSocket = new WebSocket(
          "ws://" + window.location.host + "/ws/cpu/"
      );

      const cpuChartCtx = document.getElementById("cpuChart").getContext("2d");
      cpuChart = new Chart(cpuChartCtx, {
          type: "line",
          data: {
              labels: [],
              datasets: [{
                  label: "CPU Usage",
                  data: [],
                  borderColor: "rgba(75, 192, 192, 1)",
                  backgroundColor: "rgba(75, 192, 192, 0.2)",
                  fill: true,
              }]
          },
          options: {
              scales: {
                  y: {
                      beginAtZero: true,
                      max: 100,
                      title: {
                          display: true,
                          text: 'Usage (%)'
                      }
                  },
                  x: {
                      title: {
                          display: true,
                          text: 'Time'
                      }
                  }
              },
              animation: {
                  duration: 0
              },
              responsive: true,
              maintainAspectRatio: false
          }
      });

      cpuSocket.onmessage = function (e) {
          const data = JSON.parse(e.data);
          if (data.type === 'cpu_usage') {
              const cpuData = data.data;

              // Update chart data
              cpuChart.data.labels = cpuData.map(d => {
                  const date = new Date(d.recorded_at);
                  return date.toLocaleTimeString();
              });
              cpuChart.data.datasets[0].data = cpuData.map(d => d.usage);

              // Update chart
              cpuChart.update();
          }
      };
      // Memory WebSocket connection and chart
      const memorySocket = new WebSocket(
          "ws://" + window.location.host + "/ws/memory/"
      );

      const memoryChartCtx = document.getElementById("memoryChart").getContext("2d");
      memoryChart = new Chart(memoryChartCtx, {
          type: "line",
          data: {
              labels: [],
              datasets: [{
                  label: "Memory Usage",
                  data: [],
                  borderColor: "rgba(153, 102, 255, 1)",
                  backgroundColor: "rgba(153, 102, 255, 0.2)",
                  fill: true,
              }]
          },
          options: {
              scales: {
                  y: {
                      beginAtZero: true,
                      max: 100,
                      title: {
                          display: true,
                          text: 'Usage (%)'
                      }
                  },
                  x: {
                      title: {
                          display: true,
                          text: 'Time'
                      }
                  }
              },
              animation: {
                  duration: 0
              },
              responsive: true,
              maintainAspectRatio: false
          }
      });

      memorySocket.onmessage = function (e) {
          const data = JSON.parse(e.data);
          if (data.type === 'memory_usage') {
              const memoryData = data.data;

              // Update chart data
              memoryChart.data.labels = memoryData.map(d => {
                  const date = new Date(d.recorded_at);
                  return date.toLocaleTimeString();
              });
              memoryChart.data.datasets[0].data = memoryData.map(d => d.usage);

              // Update chart
              memoryChart.update();
          }
      };

      function openDirectory(path) {
          // Send cd command via WebSocket
          fileSocket.send(JSON.stringify({
              action: 'cd',
              path: path
          }));

          // Update UI
          document.getElementById('currentPath').value = path;

          // List contents
          fileSocket.send(JSON.stringify({
              action: 'list',
              path: path
          }));
      }

      function deleteFile(path) {
          if (confirm('Are you sure you want to delete this item?')) {
              // Send rm command via WebSocket
              fileSocket.send(JSON.stringify({
                  action: 'delete',
                  path: path
              }));
          }
      }

      function updateFileTable(files) {
        const tbody = document.getElementById("fileTableBody");
        if (!tbody) {
            console.error("fileTableBody element not found");
            return;
        }

        const scrollPosition = tbody.parentElement.scrollTop;
        tbody.innerHTML = "";

        files.forEach(file => {
            const row = document.createElement("tr");
            row.draggable = true;
            row.classList.add('draggable');

            // Événements de glisser-déposer
            row.addEventListener('dragstart', handleDragStart);
            row.addEventListener('dragend', handleDragEnd);

            row.innerHTML = `
                <td>${file.name}</td>
                <td>${file.type}</td>
                <td>${formatSize(file.size)}</td>
                <td>${new Date(file.modified_at).toLocaleString()}</td>
                <td>${file.permissions}</td>
                <td>
                    ${file.type === 'directory' ?
                        `<button onclick="openDirectory('${file.path}')" class="open-btn">Open</button>` :
                        ''
                    }
                    <button onclick="deleteFile('${file.path}')" class="delete-btn">Delete</button>
                </td>
            `;
            tbody.appendChild(row);
        });

        // Restore scroll position
        tbody.parentElement.scrollTop = scrollPosition;
    }

      function navigateUp() {
          const currentPath = document.getElementById('currentPath').value;
          // Get parent directory path
          const parentPath = currentPath.split('/').slice(0, -1).join('/') || '/';

          fileSocket.send(JSON.stringify({
              action: 'cd',
              path: parentPath
          }));

          // Update UI
          document.getElementById('currentPath').value = parentPath;

          // List contents of parent directory
          fileSocket.send(JSON.stringify({
              action: 'list',
              path: parentPath
          }));
      }

      function refreshFiles() {
          const currentPath = document.getElementById('currentPath').value;
          fileSocket.send(JSON.stringify({
              action: 'list',
              path: currentPath
          }));
      }

      // Helper function to format file sizes
      function formatSize(bytes) {
          const units = ['B', 'KB', 'MB', 'GB', 'TB'];
          let size = bytes;
          let unitIndex = 0;

          while (size >= 1024 && unitIndex < units.length - 1) {
              size /= 1024;
              unitIndex++;
          }

          return `${size.toFixed(1)} ${units[unitIndex]}`;
      }

      // Drag and drop handlers
      function handleDragStart(e) {
        e.target.closest('tr').classList.add('dragging');
        const row = e.target.closest('tr');
        const fileData = {
            name: row.cells[0].textContent,
            path: row.cells[0].textContent,
            type: row.cells[1].textContent
        };
        e.dataTransfer.setData('application/json', JSON.stringify(fileData));
      }

      // Ajouter cette fonction manquante
      function handleDragEnd(e) {
        e.target.closest('tr').classList.remove('dragging');
      }

      function handleDragOver(e) {
        e.preventDefault();
        const dragZone = e.currentTarget;
        dragZone.classList.add('drag-over');
      }

      function handleDragLeave(e) {
        e.currentTarget.classList.remove('drag-over');
      }

      function handleDrop(e) {
        e.preventDefault();
        e.currentTarget.classList.remove('drag-over');
        try {
            const data = JSON.parse(e.dataTransfer.getData('application/json'));
            const destinationPath = document.getElementById('currentPath').value;
            const sourcePath = data.path;

            const destinationFullPath = destinationPath === '/' ?
                `/${sourcePath}` :
                `${destinationPath}/${sourcePath}`;

            fileSocket.send(JSON.stringify({
                action: 'move',
                source: sourcePath,
                destination: destinationFullPath
            }));
        } catch (error) {
            console.error('Erreur lors du drop:', error);
        }
      }
      // Shell WebSocket connection
      const shellSocket = new WebSocket(
          "ws://" + window.location.host + "/ws/shell/"
      );

      shellSocket.onmessage = function (e) {
        const data = JSON.parse(e.data);
        if (data.type === 'shell_output') {
            const output = document.getElementById('shellOutput');
            const lines = data.output.split('\n');

            // Ajouter un espace avant la nouvelle commande
            const spacerBefore = document.createElement('div');
            spacerBefore.style.height = '16px';
            output.appendChild(spacerBefore);

            // Créer le conteneur pour la commande et sa sortie
            const commandBlock = document.createElement('div');
            commandBlock.className = 'shell-block';

            // Afficher la commande une seule fois
            const commandLine = document.createElement('div');
            commandLine.className = 'shell-line';
            commandLine.innerHTML = `<span class="shell-prompt">$</span> <span class="shell-command">${document.getElementById('shellCommand').value}</span>`;
            commandBlock.appendChild(commandLine);

            // Ajouter un petit espace après la commande
            const spacerAfter = document.createElement('div');
            spacerAfter.style.height = '8px';
            commandBlock.appendChild(spacerAfter);

            // Traiter toutes les lignes de sortie dans un seul bloc
            const outputBlock = document.createElement('div');
            outputBlock.className = 'shell-output-block';

            lines.forEach(line => {
                if (line.trim()) {
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'shell-line';

                    // Coloration syntaxique
                    if (line.startsWith('error') || line.startsWith('Error') || line.includes('not found')) {
                        lineDiv.classList.add('shell-error');
                    } else if (line.match(/^drwx|^-rw/)) {
                        line = line.replace(/([drwx-]{10})/, '<span class="shell-permission">$1</span>');
                        if (line.includes('drwx')) {
                            line = line.replace(/([^\s]+)$/, '<span class="shell-directory">$1</span>');
                        } else {
                            line = line.replace(/([^\s]+)$/, '<span class="shell-file">$1</span>');
                        }
                    }

                    lineDiv.innerHTML = line;
                    outputBlock.appendChild(lineDiv);
                }
            });

            commandBlock.appendChild(outputBlock);
            output.appendChild(commandBlock);
            output.scrollTop = output.scrollHeight;
        }
      };

      function sendCommand() {
          const command = document.getElementById('shellCommand').value;
          shellSocket.send(JSON.stringify({
              'command': command
          }));
          document.getElementById('shellCommand').value = '';
      }

      // Support for Enter key
      document.getElementById('shellCommand').addEventListener('keypress', function (e) {
          if (e.key === 'Enter') {
              sendCommand();
          }
      });

      // Storage WebSocket connection
      const storageSocket = new WebSocket(
          "ws://" + window.location.host + "/ws/storage/"
      );

      storageSocket.onmessage = function (e) {
          const data = JSON.parse(e.data);
          if (data.type === 'storage_info') {
              updateStorageInfo(data.data);
          }
      };

      function updateStorageInfo(storageData) {
          const container = document.getElementById('storageList');
          container.innerHTML = '';

          storageData.forEach(storage => {
              const item = document.createElement('div');
              item.className = 'storage-item';
              item.innerHTML = `
                  <h4>${storage.mount_point} (${storage.device})</h4>
                  <p>Filesystem: ${storage.fs_type}</p>
                  <div class="storage-progress">
                      <div class="storage-bar" style="width: ${storage.percent_used}%"></div>
                  </div>
                  <p>${formatSize(storage.used)} used of ${formatSize(storage.total)} (${storage.percent_used.toFixed(1)}%)</p>
                  <p>${formatSize(storage.free)} free</p>
              `;
              container.appendChild(item);
          });
      }

      // Vérifiez la connexion WebSocket
      const temperatureSocket = new WebSocket(
          "ws://" + window.location.host + "/ws/temperature/"
      );

      temperatureSocket.onmessage = function (e) {
          const data = JSON.parse(e.data);
          if (data.type === 'temperature_info') {
              if (Object.keys(data.data).length === 0) {
                  console.error("No temperature data received");
              } else {
                  updateTemperatureInfo(data.data);
              }
          }
      };

      // Fonction pour mettre à jour les informations de température
      function updateTemperatureInfo(tempData) {
        const container = document.getElementById('temperatureList');
        container.innerHTML = '';

        for (const [device, sensors] of Object.entries(tempData)) {
            const deviceDiv = document.createElement('div');
            deviceDiv.className = 'temperature-item';
            let html = `<h4>${device}</h4>`;

            sensors.forEach(sensor => {
                const percentage = sensor.high ? (sensor.current / sensor.high) * 100 : 0;
                const warningClass = percentage > 80 ? 'warning' : percentage > 90 ? 'critical' : '';

                // Utiliser l'unité fournie par le backend
                html += `
                    <p>${sensor.label}: ${sensor.current.toFixed(1)}${sensor.unit}</p>
                    <div class="temperature-progress">
                        <div class="temperature-bar ${warningClass}"
                            style="width: ${percentage}%"></div>
                    </div>
                    ${sensor.high ? `<small>Max: ${sensor.high}${sensor.unit}</small>` : ''}
                    ${sensor.critical ? `<small>Critical: ${sensor.critical}${sensor.unit}</small>` : ''}
                `;
            });

            deviceDiv.innerHTML = html;
            container.appendChild(deviceDiv);
        }
    };

    // Add mobile menu toggle function
    function toggleMobileMenu() {
        document.querySelector('.nav-menu').classList.toggle('active');
    }

    // Close mobile menu when clicking outside
    document.addEventListener('click', function(event) {
        const navMenu = document.querySelector('.nav-menu');
        const mobileToggle = document.querySelector('.mobile-menu-toggle');

        if (!navMenu.contains(event.target) && !mobileToggle.contains(event.target)) {
            navMenu.classList.remove('active');
        }
    });

    // Adjust chart sizes on window resize
    window.addEventListener('resize', function() {
      const charts = [cpuChart, memoryChart, networkChart];
      charts.forEach(chart => {
          if (chart && typeof chart.resize === 'function') {
              chart.resize();
          }
      });
  });

  // ==========================================
  // SCRIPTS D'ACCESSIBILITÉ DASHBOARD
  // ==========================================
</script>

<!-- Scripts d'accessibilité spécifiques au dashboard -->
{% load static %}
<script src="{% static 'js/dashboard-accessibility.js' %}"></script>

<script>
  // Améliorer l'accessibilité des fonctions existantes
  
  // Override de switchChart pour l'accessibilité
  const originalSwitchChart = window.switchChart;
  window.switchChart = function() {
    if (originalSwitchChart) {
      originalSwitchChart();
    }
    
    // Notifier le changement pour l'accessibilité
    if (window.dashboardAccessibility) {
      const selector = document.getElementById('chartSelector');
      if (selector) {
        window.dashboardAccessibility.handleChartChange(selector.value);
      }
    }
  };

  // Override des fonctions de filtrage et tri pour l'accessibilité
  const originalFilterProcesses = window.filterProcesses;
  window.filterProcesses = function() {
    if (originalFilterProcesses) {
      originalFilterProcesses();
    }
    
    // Annoncer le résultat du filtrage
    setTimeout(() => {
      const visibleRows = document.querySelectorAll('#processesTableBody tr:not([style*="display: none"]):not(.loading-row)');
      const count = visibleRows.length;
      const message = count === 0 ? 
        'Aucun processus trouvé avec ce filtre' : 
        `${count} processus ${count > 1 ? 'trouvés' : 'trouvé'}`;
      
      if (window.accessibilityManager) {
        window.accessibilityManager.announceToScreenReader(message);
      }
    }, 100);
  };

  const originalSortProcesses = window.sortProcesses;
  window.sortProcesses = function(sortType) {
    if (originalSortProcesses) {
      originalSortProcesses(sortType);
    }
    
    // Notifier le tri
    if (window.dashboardAccessibility) {
      window.dashboardAccessibility.announceSort(sortType);
    }
  };

  // Améliorer les WebSocket updates pour l'accessibilité
  function enhanceWebSocketForAccessibility(socket, dataType) {
    const originalOnMessage = socket.onmessage;
    
    socket.onmessage = function(e) {
      if (originalOnMessage) {
        originalOnMessage.call(this, e);
      }
      
      // Mettre à jour les données pour l'accessibilité
      try {
        const data = JSON.parse(e.data);
        if (window.dashboardAccessibility && data.type && data.data) {
          // Mettre à jour les données de graphique si disponibles
          if (dataType === 'cpu' || dataType === 'memory' || dataType === 'network') {
            window.dashboardAccessibility.updateChartData(dataType, [data.data]);
          }
        }
      } catch (err) {
        console.log('Erreur parsing WebSocket data pour accessibilité:', err);
      }
    };
  }

  // Appliquer les améliorations aux WebSockets existants
  document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
      // Améliorer les connexions WebSocket si elles existent
      if (window.cpuSocket) enhanceWebSocketForAccessibility(window.cpuSocket, 'cpu');
      if (window.memorySocket) enhanceWebSocketForAccessibility(window.memorySocket, 'memory');
      if (window.networkSocket) enhanceWebSocketForAccessibility(window.networkSocket, 'network');
    }, 1000);
  });

  // Fonction d'aide pour créer des boutons d'action accessibles
  function createAccessibleActionButton(text, onClick, ariaLabel) {
    const button = document.createElement('button');
    button.textContent = text;
    button.className = 'accessible-button';
    button.setAttribute('aria-label', ariaLabel || text);
    button.addEventListener('click', onClick);
    return button;
  }

  // Améliorer les boutons d'action dynamiques
  function enhanceActionButtons() {
    const actionButtons = document.querySelectorAll('tbody button:not([aria-label])');
    actionButtons.forEach(button => {
      const text = button.textContent.trim();
      const row = button.closest('tr');
      const itemName = row?.querySelector('td:first-child')?.textContent.trim();
      
      if (itemName && text) {
        const actionLabels = {
          'Stop': `Arrêter ${itemName}`,
          'Start': `Démarrer ${itemName}`,
          'Restart': `Redémarrer ${itemName}`,
          'Kill': `Terminer ${itemName}`,
          'Terminate': `Terminer ${itemName}`
        };
        
        const label = actionLabels[text] || `${text} ${itemName}`;
        button.setAttribute('aria-label', label);
        button.classList.add('accessible-button');
      }
    });
  }

  // Appliquer les améliorations périodiquement pour les éléments dynamiques
  setInterval(enhanceActionButtons, 2000);
</script>
{% endblock %}
